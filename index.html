<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<title>Haskell-Style Parsing and Interpretation</title>
<!-- 2016-05-12 Thu 18:16 -->
<meta  http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta  name="generator" content="Org-mode" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center; }
  .todo   { font-family: monospace; color: red; }
  .done   { color: green; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  pre.src-sh:before    { content: 'sh'; }
  pre.src-bash:before  { content: 'sh'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-R:before     { content: 'R'; }
  pre.src-perl:before  { content: 'Perl'; }
  pre.src-java:before  { content: 'Java'; }
  pre.src-sql:before   { content: 'SQL'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.right  { text-align: center;  }
  th.left   { text-align: center;   }
  th.center { text-align: center; }
  td.right  { text-align: right;  }
  td.left   { text-align: left;   }
  td.center { text-align: center; }
  dt { font-weight: bold; }
  .footpara:nth-child(2) { display: inline; }
  .footpara { display: block; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  /*]]>*/-->
</style>
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2013 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
</head>
<body>
<div id="content">
<h1 class="title">Haskell-Style Parsing and Interpretation</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">1. Introduction</a>
<ul>
<li><a href="#sec-1-1">1.1. Audience</a></li>
</ul>
</li>
<li><a href="#sec-2">2. Abstract Syntax Trees</a>
<ul>
<li><a href="#sec-2-1">2.1. Files and Modules</a></li>
<li><a href="#sec-2-2">2.2. Testing</a></li>
</ul>
</li>
<li><a href="#sec-3">3. Regular Expressions</a>
<ul>
<li><a href="#sec-3-1">3.1. Modules and Directories</a></li>
<li><a href="#sec-3-2">3.2. Testing</a></li>
</ul>
</li>
<li><a href="#sec-4">4. Context-Free Grammars</a></li>
<li><a href="#sec-5">5. Context-Sensitive Languages</a></li>
<li><a href="#sec-6">6. Interpretation</a></li>
</ul>
</div>
</div>

<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1"><span class="section-number-2">1</span> Introduction</h2>
<div class="outline-text-2" id="text-1">
<p>
Haskell is a language full of embedded domain-specific languages. A
"domain-specific language", or DSL, is a language specialized for a particular
purpose, or "domain". The benefit of a DSL is that it can offer programming
primitives directly relevant to your domain, while guarding you from common
domain pitfalls. Some languages come with libraries and frameworks, while
others offer full-blown, embedded DSLs.
</p>

<p>
This document presents a couple embedded Haskell DSLs for the parsing and
interpretation of some regular, context-free, and context-sensitive languages.
The distinction between these language classes will be made clear along the
way. The DSLs presented are "embedded" in the sense that you always have the
full power of Haskell at your fingertips.
</p>

<p>
Not all programming langugages allow the "embedding" of domain-specific
languages. This demands that the designer of a language library can
define new, and override existing operators and control-flow structures.
</p>

<p>
For instance, C++, C#, and Python, all allow advanced operator overloading, but
none of them let you to modify the behaviour of sequencing program statements
(in C# and C++, the <code>;</code> operator).  Haskell lets you do this.
</p>

<p>
Haskell is also a functional programming language; which in this case means
that it comes with quick and (relatively) painless "glue code" for binding
seemingly disparate domain-specific code, into one cohesive whole (e.g.,
binding the stages of a compiler or interpreter).
</p>
</div>

<div id="outline-container-sec-1-1" class="outline-3">
<h3 id="sec-1-1"><span class="section-number-3">1.1</span> Audience</h3>
<div class="outline-text-3" id="text-1-1">
<p>
The principal target audience for this tutorial are
<a href="http://www.diku.dk/">DIKU</a> students, coming to learn Haskell after having
taken an undergraduate course on Compiler Construction.
</p>
</div>
</div>
</div>

<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2"><span class="section-number-2">2</span> Abstract Syntax Trees</h2>
<div class="outline-text-2" id="text-2">
<p>
The input to a compiler or interpreter is an unstructured stream of bytes. To
do any useful work, we recast this stream of bytes into a more structured data
type, an abstract syntax tree. In a conventional, multi-pass compiler this is
the job of a lexer and/or parser.
</p>

<p>
For instance, consider the strings "2+5*8" and "5*8+3". To evaluate such
arithmetical expressions properly, we need to mind the rules of operator
precedence. One possible abstract syntax tree for such arithmetical expressions
can be defined as follows:
</p>

<div class="org-src-container">

<pre class="src src-haskell">data Expr = Add Expr Expr
	  | Mul Expr Expr
	  | Num Integer
	  deriving (Show)
</pre>
</div>

<p>
This defines a type constructor <code>Expr</code>, with three data constructors:
</p>

<div class="org-src-container">

<pre class="src src-haskell">Add :: Expr -&gt; Expr -&gt; Expr
Mul :: Expr -&gt; Expr -&gt; Expr
Num :: Integer -&gt; Expr
</pre>
</div>

<p>
This notation means that <code>Add</code> and <code>Mul</code> are functions that given two <code>Expr</code>,
yield an <code>Expr</code>, and <code>Num</code> is a function that given an <code>Integer</code> yields an
<code>Expr</code>.
</p>

<p>
The last line of the <code>Expr</code> declaration:
</p>

<div class="org-src-container">

<pre class="src src-haskell">deriving (Show)
</pre>
</div>

<p>
Means that Haskell should employ some default behaviour when you attempt to
print values of type <code>Expr</code>. Without this line, the Haskell will complain that
<code>Expr</code> is not an instance of <code>Show</code>, and so cannot be "shown".
</p>

<p>
The above strings would then be represented as the <code>Expr</code> values <code>(Add (Num 2)
(Mul (Num 5) (Num 8)))</code> and <code>(Add (Mul (Num 5) (Num 8)) (Num 3))</code>.
</p>

<p>
Here, evaluation order no longer is ambiguous, and we can walk the syntax tree
to evaluate it:
</p>

<div class="org-src-container">

<pre class="src src-haskell">eval :: Expr -&gt; Integer
eval (Add e1 e2) = (eval e1) + (eval e2)
eval (Mul e1 e2) = (eval e1) * (eval e2)
eval (Num x) = x
</pre>
</div>
</div>

<div id="outline-container-sec-2-1" class="outline-3">
<h3 id="sec-2-1"><span class="section-number-3">2.1</span> Files and Modules</h3>
<div class="outline-text-3" id="text-2-1">
<p>
A Haskell file begins with a <code>module</code> declaration:
</p>

<div class="org-src-container">

<pre class="src src-haskell">module Ast where

data Expr = Add Expr Expr
	  | Mul Expr Expr
	  | Num Integer
	  deriving (Show)
</pre>
</div>

<p>
The basename of the Haskell file name must be the name of the module (e.g.,
the above module should be stored in a file called <code>Ast.hs</code>).
</p>
</div>
</div>

<div id="outline-container-sec-2-2" class="outline-3">
<h3 id="sec-2-2"><span class="section-number-3">2.2</span> Testing</h3>
<div class="outline-text-3" id="text-2-2">
<p>
<code>ghci</code>
</p>
</div>
</div>
</div>

<div id="outline-container-sec-3" class="outline-2">
<h2 id="sec-3"><span class="section-number-2">3</span> Regular Expressions</h2>
<div class="outline-text-2" id="text-3">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="left" />

<col  class="left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="left">Regex</th>
<th scope="col" class="left">Haskell</th>
</tr>
</thead>
<tbody>
<tr>
<td class="left"><i>x</i></td>
<td class="left"><code>char :: Char -&gt; Parser Char</code></td>
</tr>

<tr>
<td class="left"><i>xyz</i></td>
<td class="left"><code>string :: String -&gt; Parser String</code></td>
</tr>

<tr>
<td class="left">&vert;</td>
<td class="left"><code>(+++) :: Parser a -&gt; Parser a -&gt; Parser a</code></td>
</tr>

<tr>
<td class="left"><code>*</code></td>
<td class="left"><code>many :: Parser a -&gt; Parser [a]</code></td>
</tr>

<tr>
<td class="left"><code>+</code></td>
<td class="left"><code>many1 :: Parser a -&gt; Parser (a, [a])</code></td>
</tr>

<tr>
<td class="left"><code>?</code></td>
<td class="left"><code>option :: Parser a -&gt; a -&gt; Parser a</code></td>
</tr>

<tr>
<td class="left"><code>[]</code></td>
<td class="left"><code>choose :: [a] -&gt; Parser a</code></td>
</tr>
</tbody>
</table>

<p>
Before considering
</p>
</div>

<div id="outline-container-sec-3-1" class="outline-3">
<h3 id="sec-3-1"><span class="section-number-3">3.1</span> Modules and Directories</h3>
<div class="outline-text-3" id="text-3-1">
<p>
Modules can be structured in directories. This allows you hide module
internals, while permitting submodules with broad access rights. This in turn
lets you write internal module tests, while exporting
</p>

<p>
We can put the implementation of the parser in <code>Parser/Impl.hs</code>, exporting
everything:
</p>

<div class="org-src-container">

<pre class="src src-haskell">module Parser.Impl where
</pre>
</div>

<p>
This allows to write a comprehensive test module testing parser internals in
<code>Parser/Test.hs</code>:
</p>

<div class="org-src-container">

<pre class="src src-haskell">module Parser.Test where
</pre>
</div>

<p>
As to the parser itself, we can declare a new module which imports
<code>Parser.Impl</code>, but hides all unnecessary functionality:
</p>

<div class="org-src-container">

<pre class="src src-haskell">module Parser where

import Parser.Impl
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-3-2" class="outline-3">
<h3 id="sec-3-2"><span class="section-number-3">3.2</span> Testing</h3>
<div class="outline-text-3" id="text-3-2">
<p>
Shell scripts.
</p>

<div class="org-src-container">

<pre class="src src-sh">#!/usr/bin/env bash

set -euo pipefail

ghci -v0 Parser.hs &lt;&lt;EOF

EOF
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-sec-4" class="outline-2">
<h2 id="sec-4"><span class="section-number-2">4</span> Context-Free Grammars</h2>
</div>

<div id="outline-container-sec-5" class="outline-2">
<h2 id="sec-5"><span class="section-number-2">5</span> Context-Sensitive Languages</h2>
</div>

<div id="outline-container-sec-6" class="outline-2">
<h2 id="sec-6"><span class="section-number-2">6</span> Interpretation</h2>
</div>
</div>
<div id="postamble" class="status">
<p class="date">Created: 2016-05-12 Thu 18:16</p>
<p class="creator"><a href="http://www.gnu.org/software/emacs/">Emacs</a> 24.5.1 (<a href="http://orgmode.org">Org</a> mode 8.2.10)</p>
<p class="validation"><a href="http://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
